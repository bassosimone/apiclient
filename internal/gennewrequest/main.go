package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"
	"time"

	"github.com/bassosimone/apiclient/internal/apimodel"
	"github.com/bassosimone/apiclient/internal/fatalx"
	"github.com/bassosimone/apiclient/internal/reflectx"
)

func gettype(in interface{}) string {
	sinfo, err := reflectx.NewStructInfo(in)
	fatalx.OnError(err, "reflectx.NewStructInfo failed")
	return sinfo.TypeName()
}

func gettags(in interface{}, tagName string) []*reflectx.FieldInfo {
	sinfo, err := reflectx.NewStructInfo(in)
	fatalx.OnError(err, "reflectx.NewStructInfo failed")
	return sinfo.AllFieldsWithTag(tagName)
}

func genbeginfunc(filep *os.File, desc *apimodel.Descriptor) {
	typename := gettype(desc.Request)
	fmt.Fprintf(filep, "// New%s creates a new %s\n", typename, typename)
	fmt.Fprintf(filep, "func New%s", typename)
	fmt.Fprint(filep, "(ctx context.Context, ")
	fmt.Fprint(filep, "baseURL string, ")
	fmt.Fprintf(filep, "req *%s)", typename)
	fmt.Fprint(filep, " (*http.Request, error) {\n")
}

func genurlpath(filep *os.File, desc *apimodel.Descriptor) {
	if !strings.Contains(desc.URLPath, "{{ ") {
		fmt.Fprintf(filep, "\tURL.Path = \"%s\"\n", desc.URLPath)
		return
	}
	fmt.Fprintf(filep, "\ttmpl, err := template.New(\"urlpath\").Parse(\"%s\")\n", desc.URLPath)
	fmt.Fprint(filep, "\tif err != nil {\n")
	fmt.Fprint(filep, "\t\treturn nil, err\n")
	fmt.Fprint(filep, "\t}\n")
	fmt.Fprint(filep, "\tvar urlpath strings.Builder\n")
	fmt.Fprint(filep, "\terr = tmpl.Execute(&urlpath, req)\n")
	fmt.Fprint(filep, "\tif err != nil {\n")
	fmt.Fprint(filep, "\t\treturn nil, err\n")
	fmt.Fprint(filep, "\t}\n")
	fmt.Fprint(filep, "\tURL.Path = urlpath.String()\n")
}

func genqueryforstring(filep *os.File, field *reflectx.FieldInfo) {
	name := field.Self.Name
	query := field.Self.Tag.Get("query")
	if field.Self.Tag.Get("mandatory") == "true" {
		fmt.Fprintf(filep, "\tif req.%s == \"\" {\n", name)
		fmt.Fprint(filep, "\t\treturn nil, errors.New(")
		fmt.Fprintf(filep, "\"apiclient: empty %s field\")\n", name)
		fmt.Fprintf(filep, "\t}\n")
		fmt.Fprintf(filep, "\tquery.Add(\"%s\", ", query)
		fmt.Fprintf(filep, "req.%s)\n", name)
		return
	}
	fmt.Fprintf(filep, "\tif req.%s != \"\" {\n", name)
	fmt.Fprintf(filep, "\t\tquery.Add(\"%s\", ", query)
	fmt.Fprintf(filep, "req.%s)\n", name)
	fmt.Fprintf(filep, "\t}\n")
}

func genqueryforbool(filep *os.File, field *reflectx.FieldInfo) {
	name := field.Self.Name
	query := field.Self.Tag.Get("query")
	// mandatory does not make much sense for a boolean field
	fmt.Fprintf(filep, "\tif req.%s {\n", name)
	fmt.Fprintf(filep, "\t\tquery.Add(\"%s\", \"true\")\n", query)
	fmt.Fprintf(filep, "\t}\n")
}

func genqueryforint64(filep *os.File, field *reflectx.FieldInfo) {
	name := field.Self.Name
	query := field.Self.Tag.Get("query")
	// mandatory does not make much sense for an integer field
	fmt.Fprintf(filep, "\tif req.%s != 0 {\n", name)
	fmt.Fprintf(filep, "\t\tquery.Add(\"%s\", fmt.Sprintf(\"%%d\", req.%s))\n", query, name)
	fmt.Fprintf(filep, "\t}\n")
}

func genquery(filep *os.File, desc *apimodel.Descriptor) {
	if desc.Method == "POST" {
		return
	}
	fields := gettags(desc.Request, "query")
	if fields == nil {
		return
	}
	fmt.Fprint(filep, "\tquery := url.Values{}\n")
	for _, field := range fields {
		switch field.Self.Type.Kind() {
		case reflect.String:
			genqueryforstring(filep, field)
		case reflect.Bool:
			genqueryforbool(filep, field)
		case reflect.Int64:
			genqueryforint64(filep, field)
		default:
			panic("query: unsupported field type")
		}
	}
	fmt.Fprint(filep, "\tURL.RawQuery = query.Encode()\n")
}

func gencreaterequest(filep *os.File, desc *apimodel.Descriptor) {
	if desc.Method == "POST" {
		fmt.Fprint(filep, "\tbody, err := json.Marshal(req)\n")
		fmt.Fprint(filep, "\tif err != nil {\n")
		fmt.Fprint(filep, "\t\treturn nil, err\n")
		fmt.Fprint(filep, "\t}\n")
	}
	fmt.Fprint(filep, "\treturn http.NewRequestWithContext(")
	fmt.Fprintf(filep, "ctx, \"%s\", URL.String(), ", desc.Method)
	if desc.Method != "POST" {
		fmt.Fprint(filep, "nil)\n")
		return
	}
	fmt.Fprint(filep, "bytes.NewReader(body))\n")
}

func genmakeurl(filep *os.File, desc *apimodel.Descriptor) {
	fmt.Fprint(filep, "\tURL, err := url.Parse(baseURL)\n")
	fmt.Fprint(filep, "\tif err != nil {\n")
	fmt.Fprint(filep, "\t\treturn nil, err\n")
	fmt.Fprint(filep, "\t}\n")
}

func genendfunc(filep *os.File) {
	fmt.Fprintf(filep, "}\n\n")
}

func genapi(filep *os.File, desc *apimodel.Descriptor) {
	genbeginfunc(filep, desc)
	genmakeurl(filep, desc)
	genurlpath(filep, desc)
	genquery(filep, desc)
	gencreaterequest(filep, desc)
	genendfunc(filep)
}

func main() {
	filep, err := os.Create("newrequest.go")
	fatalx.OnError(err, "os.Create failed")

	// TODO(bassosimone): handle all the possible write errors

	fmt.Fprint(filep, "// Code generated by go generate; DO NOT EDIT.\n")
	fmt.Fprintf(filep, "// %v\n\n", time.Now())
	fmt.Fprint(filep, "package apiclient\n\n")
	fmt.Fprint(filep, "import (\n")
	fmt.Fprint(filep, "\t\"bytes\"\n")
	fmt.Fprint(filep, "\t\"context\"\n")
	fmt.Fprint(filep, "\t\"encoding/json\"\n")
	fmt.Fprint(filep, "\t\"errors\"\n")
	fmt.Fprint(filep, "\t\"fmt\"\n")
	fmt.Fprint(filep, "\t\"text/template\"\n")
	fmt.Fprint(filep, "\t\"net/http\"\n")
	fmt.Fprint(filep, "\t\"net/url\"\n")
	fmt.Fprint(filep, "\t\"strings\"\n")
	fmt.Fprint(filep, ")\n\n")

	for _, descr := range apimodel.Descriptors {
		genapi(filep, &descr)
	}

	err = filep.Close()
	fatalx.OnError(err, "filep.Close failed")
}
