// Code generated by go generate; DO NOT EDIT.
// 2021-02-16 08:53:50.1040093 +0100 CET m=+0.000240117

package apiclient

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"io"
	"net/http"
)

//go:generate go run ./internal/gennewresponse/...

func (api *CheckReportIDAPI) newResponse(resp *http.Response, err error) (*CheckReportIDResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out CheckReportIDResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *CheckInAPI) newResponse(resp *http.Response, err error) (*CheckInResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out CheckInResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *LoginAPI) newResponse(resp *http.Response, err error) (*LoginResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out LoginResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *MeasurementMetaAPI) newResponse(resp *http.Response, err error) (*MeasurementMetaResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out MeasurementMetaResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *RegisterAPI) newResponse(resp *http.Response, err error) (*RegisterResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out RegisterResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *TestHelpersAPI) newResponse(resp *http.Response, err error) (TestHelpersResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out TestHelpersResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

func (api *PsiphonConfigAPI) newResponse(resp *http.Response, err error) (PsiphonConfigResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out PsiphonConfigResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

func (api *TorTargetsAPI) newResponse(resp *http.Response, err error) (TorTargetsResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out TorTargetsResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

func (api *URLsAPI) newResponse(resp *http.Response, err error) (*URLsResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out URLsResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *OpenReportAPI) newResponse(resp *http.Response, err error) (*OpenReportResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out OpenReportResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

func (api *SubmitMeasurementAPI) newResponse(resp *http.Response, err error) (*SubmitMeasurementResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("%w: %d", ErrHTTPFailure, resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	var out SubmitMeasurementResponse
	if err := json.Unmarshal(data, &out); err != nil {
		return nil, err
	}
	return &out, nil
}

