// Code generated by go generate; DO NOT EDIT.
// 2021-02-17 15:04:26.855653957 +0100 CET m=+0.000402691

package apiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"io/ioutil"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/bassosimone/apiclient/internal/imodel"
	"github.com/bassosimone/apiclient/model"
)

//go:generate go run ./internal/cmd/generator

// CheckReportID calls the CheckReportID API.
func (c *Client) CheckReportID(ctx context.Context, req *model.CheckReportIDRequest) (*model.CheckReportIDResponse, error) {
	return newCheckReportIDAPI(c).call(ctx, req)
}

type checkReportIDAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newCheckReportIDAPI(c *Client) *checkReportIDAPI {
	api := &checkReportIDAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *checkReportIDAPI) call(ctx context.Context, in *model.CheckReportIDRequest) (*model.CheckReportIDResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *checkReportIDAPI) newRequestQuery(req *model.CheckReportIDRequest) (string, error) {
	q := url.Values{}
	if req.ReportID == "" {
		return "", newErrEmptyField("ReportID")
	}
	q.Add("report_id", req.ReportID)
	return q.Encode(), nil
}

func (api *checkReportIDAPI) newRequest(ctx context.Context, req *model.CheckReportIDRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/_/check_report_id"
	URL.RawQuery, err = api.newRequestQuery(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *checkReportIDAPI) newResponse(resp *http.Response, err error) (*model.CheckReportIDResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.CheckReportIDResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// CheckIn calls the CheckIn API.
func (c *Client) CheckIn(ctx context.Context, req *model.CheckInRequest) (*model.CheckInResponse, error) {
	return newCheckInAPI(c).call(ctx, req)
}

type checkInAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newCheckInAPI(c *Client) *checkInAPI {
	api := &checkInAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *checkInAPI) call(ctx context.Context, in *model.CheckInRequest) (*model.CheckInResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *checkInAPI) newRequest(ctx context.Context, req *model.CheckInRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/check-in"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *checkInAPI) newResponse(resp *http.Response, err error) (*model.CheckInResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.CheckInResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

type loginAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newLoginAPI(c *Client) *loginAPI {
	api := &loginAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *loginAPI) call(ctx context.Context, in *imodel.LoginRequest) (*imodel.LoginResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *loginAPI) newRequest(ctx context.Context, req *imodel.LoginRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/login"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *loginAPI) newResponse(resp *http.Response, err error) (*imodel.LoginResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &imodel.LoginResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// MeasurementMeta calls the MeasurementMeta API.
func (c *Client) MeasurementMeta(ctx context.Context, req *model.MeasurementMetaRequest) (*model.MeasurementMetaResponse, error) {
	return newMeasurementMetaAPI(c).call(ctx, req)
}

type measurementMetaAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newMeasurementMetaAPI(c *Client) *measurementMetaAPI {
	api := &measurementMetaAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *measurementMetaAPI) call(ctx context.Context, in *model.MeasurementMetaRequest) (*model.MeasurementMetaResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *measurementMetaAPI) newRequestQuery(req *model.MeasurementMetaRequest) (string, error) {
	q := url.Values{}
	if req.ReportID == "" {
		return "", newErrEmptyField("ReportID")
	}
	q.Add("report_id", req.ReportID)
	if req.Full {
		q.Add("full", "true")
	}
	if req.Input != "" {
		q.Add("input", req.Input)
	}
	return q.Encode(), nil
}

func (api *measurementMetaAPI) newRequest(ctx context.Context, req *model.MeasurementMetaRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/measurement_meta"
	URL.RawQuery, err = api.newRequestQuery(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *measurementMetaAPI) newResponse(resp *http.Response, err error) (*model.MeasurementMetaResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.MeasurementMetaResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

type registerAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newRegisterAPI(c *Client) *registerAPI {
	api := &registerAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *registerAPI) call(ctx context.Context, in *imodel.RegisterRequest) (*imodel.RegisterResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *registerAPI) newRequest(ctx context.Context, req *imodel.RegisterRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/register"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *registerAPI) newResponse(resp *http.Response, err error) (*imodel.RegisterResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &imodel.RegisterResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// TestHelpers calls the TestHelpers API.
func (c *Client) TestHelpers(ctx context.Context, req *model.TestHelpersRequest) (model.TestHelpersResponse, error) {
	return newTestHelpersAPI(c).call(ctx, req)
}

type testHelpersAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newTestHelpersAPI(c *Client) *testHelpersAPI {
	api := &testHelpersAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *testHelpersAPI) call(ctx context.Context, in *model.TestHelpersRequest) (model.TestHelpersResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *testHelpersAPI) newRequest(ctx context.Context, req *model.TestHelpersRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-helpers"
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *testHelpersAPI) newResponse(resp *http.Response, err error) (model.TestHelpersResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := model.TestHelpersResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

// PsiphonConfig calls the PsiphonConfig API.
func (c *Client) PsiphonConfig(ctx context.Context, req *model.PsiphonConfigRequest) (model.PsiphonConfigResponse, error) {
	return newPsiphonConfigAPI(c).call(ctx, req)
}

type psiphonConfigAPI struct {
	Authorizer authorizer
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newPsiphonConfigAPI(c *Client) *psiphonConfigAPI {
	api := &psiphonConfigAPI{
		Authorizer: c,
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *psiphonConfigAPI) call(ctx context.Context, in *model.PsiphonConfigRequest) (model.PsiphonConfigResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	if api.Authorizer == nil {
		return nil, errMissingAuthorizer
	}
	token, err := api.Authorizer.maybeRefreshToken(ctx)
	if err != nil {
		return nil, err
	}
	authorization := newAuthorizationHeader(token)
	req.Header.Add("Authorization", authorization)
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *psiphonConfigAPI) newRequest(ctx context.Context, req *model.PsiphonConfigRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-list/psiphon-config"
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *psiphonConfigAPI) newResponse(resp *http.Response, err error) (model.PsiphonConfigResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := model.PsiphonConfigResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

// TorTargets calls the TorTargets API.
func (c *Client) TorTargets(ctx context.Context, req *model.TorTargetsRequest) (model.TorTargetsResponse, error) {
	return newTorTargetsAPI(c).call(ctx, req)
}

type torTargetsAPI struct {
	Authorizer authorizer
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newTorTargetsAPI(c *Client) *torTargetsAPI {
	api := &torTargetsAPI{
		Authorizer: c,
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *torTargetsAPI) call(ctx context.Context, in *model.TorTargetsRequest) (model.TorTargetsResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	if api.Authorizer == nil {
		return nil, errMissingAuthorizer
	}
	token, err := api.Authorizer.maybeRefreshToken(ctx)
	if err != nil {
		return nil, err
	}
	authorization := newAuthorizationHeader(token)
	req.Header.Add("Authorization", authorization)
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *torTargetsAPI) newRequest(ctx context.Context, req *model.TorTargetsRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-list/tor-targets"
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *torTargetsAPI) newResponse(resp *http.Response, err error) (model.TorTargetsResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := model.TorTargetsResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

// URLs calls the URLs API.
func (c *Client) URLs(ctx context.Context, req *model.URLsRequest) (*model.URLsResponse, error) {
	return newURLsAPI(c).call(ctx, req)
}

type urlsAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newURLsAPI(c *Client) *urlsAPI {
	api := &urlsAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *urlsAPI) call(ctx context.Context, in *model.URLsRequest) (*model.URLsResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *urlsAPI) newRequestQuery(req *model.URLsRequest) (string, error) {
	q := url.Values{}
	if req.CategoryCodes != "" {
		q.Add("category_codes", req.CategoryCodes)
	}
	if req.CountryCode != "" {
		q.Add("country_code", req.CountryCode)
	}
	if req.Limit != 0 {
		q.Add("limit", newQueryFieldInt64(req.Limit))
	}
	return q.Encode(), nil
}

func (api *urlsAPI) newRequest(ctx context.Context, req *model.URLsRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-list/urls"
	URL.RawQuery, err = api.newRequestQuery(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *urlsAPI) newResponse(resp *http.Response, err error) (*model.URLsResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.URLsResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// OpenReport calls the OpenReport API.
func (c *Client) OpenReport(ctx context.Context, req *model.OpenReportRequest) (*model.OpenReportResponse, error) {
	return newOpenReportAPI(c).call(ctx, req)
}

type openReportAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newOpenReportAPI(c *Client) *openReportAPI {
	api := &openReportAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *openReportAPI) call(ctx context.Context, in *model.OpenReportRequest) (*model.OpenReportResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *openReportAPI) newRequest(ctx context.Context, req *model.OpenReportRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/report"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *openReportAPI) newResponse(resp *http.Response, err error) (*model.OpenReportResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.OpenReportResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// SubmitMeasurement calls the SubmitMeasurement API.
func (c *Client) SubmitMeasurement(ctx context.Context, req *model.SubmitMeasurementRequest) (*model.SubmitMeasurementResponse, error) {
	return newSubmitMeasurementAPI(c).call(ctx, req)
}

type submitMeasurementAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	newTemplate func(s string) textTemplate
	unmarshal   func(b []byte, v interface{}) error
}

func newSubmitMeasurementAPI(c *Client) *submitMeasurementAPI {
	api := &submitMeasurementAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *submitMeasurementAPI) call(ctx context.Context, in *model.SubmitMeasurementRequest) (*model.SubmitMeasurementResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *submitMeasurementAPI) newRequestURLPath(req *model.SubmitMeasurementRequest) (string, error) {
	newTemplate := newStdlibTextTemplate
	if api.newTemplate != nil {
		newTemplate = api.newTemplate
	}
	tmpl, err := newTemplate("urlpath").Parse("/report/{{ .ReportID }}")
	if err != nil {
		return "", err
	}
	var urlpath strings.Builder
	err = tmpl.Execute(&urlpath, req)
	if err != nil {
		return "", err
	}
	return urlpath.String(), nil
}

func (api *submitMeasurementAPI) newRequest(ctx context.Context, req *model.SubmitMeasurementRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path, err = api.newRequestURLPath(req)
	if err != nil {
		return nil, err
	}
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *submitMeasurementAPI) newResponse(resp *http.Response, err error) (*model.SubmitMeasurementResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.SubmitMeasurementResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

