// Code generated by go generate; DO NOT EDIT.
// 2021-02-18 10:25:56.024403329 +0100 CET m=+0.071765806

package apiclient

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"net/url"
	"reflect"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/bassosimone/apiclient/internal/imodel"
	"github.com/bassosimone/apiclient/model"
	"github.com/google/go-cmp/cmp"
)

//go:generate go run ./internal/cmd/generator

func TestCheckReportIDInvalidURL(t *testing.T) {
	api := &checkReportIDAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckReportIDWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &checkReportIDAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckReportIDWithNewRequestErr(t *testing.T) {
	api := &checkReportIDAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckReportIDWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &checkReportIDAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckReportIDWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &checkReportIDAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckReportIDWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &checkReportIDAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckReportIDRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &checkReportIDAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestCheckReportIDMandatoryFields(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &checkReportIDAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckReportIDRequest{} // deliberately empty
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrEmptyField) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

type handleCheckReportID struct {
	accept    string
	count     int32
	method    string
	mu        sync.Mutex
	resp      *model.CheckReportIDResponse
	url       *url.URL
	userAgent string
}

func (h *handleCheckReportID) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	var out model.CheckReportIDResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = &out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForCheckReportID(t *testing.T) {
	// setup
	handler := &handleCheckReportID{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.CheckReportIDRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.CheckReportID(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if reflect.ValueOf(*resp).IsZero() {
		t.Fatal("server returned a zero structure")
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "GET" {
		t.Fatal("we sent an unexpected method")
	}
	// check for the query
	query, err := url.ParseQuery(handler.url.RawQuery)
	if err != nil {
		t.Fatal(err)
	}
	v0 := query.Get("report_id")
	ov0 := req.ReportID
	if ov0 != v0 {
		t.Fatal("query field with unexpected value")
	}
}

func TestCheckInInvalidURL(t *testing.T) {
	api := &checkInAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &checkInAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInMarshalErr(t *testing.T) {
	api := &checkInAPI{
		BaseURL: "https://ps1.ooni.io",
		marshal: func(v interface{}) ([]byte, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInWithNewRequestErr(t *testing.T) {
	api := &checkInAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &checkInAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &checkInAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &checkInAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestCheckInRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &checkInAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

type handleCheckIn struct {
	accept    string
	req       *model.CheckInRequest
	count     int32
	method    string
	mu        sync.Mutex
	resp      *model.CheckInResponse
	url       *url.URL
	userAgent string
}

func (h *handleCheckIn) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	reqbody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	var in model.CheckInRequest
	if err := json.Unmarshal(reqbody, &in); err != nil {
		w.WriteHeader(400)
		return
	}
	if reflect.ValueOf(in).IsZero() {
		w.WriteHeader(400)
		return
	}
	h.req = &in
	var out model.CheckInResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = &out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForCheckIn(t *testing.T) {
	// setup
	handler := &handleCheckIn{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.CheckInRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.CheckIn(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if reflect.ValueOf(*resp).IsZero() {
		t.Fatal("server returned a zero structure")
	}
	if diff := cmp.Diff(req, handler.req); diff != "" {
		t.Fatal(diff)
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "POST" {
		t.Fatal("we sent an unexpected method")
	}
}

func TestLoginInvalidURL(t *testing.T) {
	api := &loginAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &loginAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginMarshalErr(t *testing.T) {
	api := &loginAPI{
		BaseURL: "https://ps1.ooni.io",
		marshal: func(v interface{}) ([]byte, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginWithNewRequestErr(t *testing.T) {
	api := &loginAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &loginAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &loginAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &loginAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestLoginRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &loginAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.LoginRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestMeasurementMetaInvalidURL(t *testing.T) {
	api := &measurementMetaAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestMeasurementMetaWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &measurementMetaAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestMeasurementMetaWithNewRequestErr(t *testing.T) {
	api := &measurementMetaAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestMeasurementMetaWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &measurementMetaAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestMeasurementMetaWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &measurementMetaAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestMeasurementMetaWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &measurementMetaAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestMeasurementMetaRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &measurementMetaAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestMeasurementMetaMandatoryFields(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &measurementMetaAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.MeasurementMetaRequest{} // deliberately empty
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrEmptyField) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

type handleMeasurementMeta struct {
	accept    string
	count     int32
	method    string
	mu        sync.Mutex
	resp      *model.MeasurementMetaResponse
	url       *url.URL
	userAgent string
}

func (h *handleMeasurementMeta) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	var out model.MeasurementMetaResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = &out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForMeasurementMeta(t *testing.T) {
	// setup
	handler := &handleMeasurementMeta{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.MeasurementMetaRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.MeasurementMeta(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if reflect.ValueOf(*resp).IsZero() {
		t.Fatal("server returned a zero structure")
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "GET" {
		t.Fatal("we sent an unexpected method")
	}
	// check for the query
	query, err := url.ParseQuery(handler.url.RawQuery)
	if err != nil {
		t.Fatal(err)
	}
	v0 := query.Get("report_id")
	ov0 := req.ReportID
	if ov0 != v0 {
		t.Fatal("query field with unexpected value")
	}
	v1 := query.Get("full")
	if v1 == "" {
		v1 = "false" // we don't send a false value
	}
	ov1 := newQueryFieldBool(req.Full)
	if ov1 != v1 {
		t.Fatal("query field with unexpected value")
	}
	v2 := query.Get("input")
	ov2 := req.Input
	if ov2 != v2 {
		t.Fatal("query field with unexpected value")
	}
}

func TestRegisterInvalidURL(t *testing.T) {
	api := &registerAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &registerAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterMarshalErr(t *testing.T) {
	api := &registerAPI{
		BaseURL: "https://ps1.ooni.io",
		marshal: func(v interface{}) ([]byte, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterWithNewRequestErr(t *testing.T) {
	api := &registerAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &registerAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &registerAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &registerAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestRegisterRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &registerAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &imodel.RegisterRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestTestHelpersInvalidURL(t *testing.T) {
	api := &testHelpersAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTestHelpersWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &testHelpersAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTestHelpersWithNewRequestErr(t *testing.T) {
	api := &testHelpersAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTestHelpersWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &testHelpersAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTestHelpersWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &testHelpersAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTestHelpersWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &testHelpersAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTestHelpersRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &testHelpersAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestTestHelpersResponseLiteralNull(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &testHelpersAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrJSONLiteralNull) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

type handleTestHelpers struct {
	accept    string
	count     int32
	method    string
	mu        sync.Mutex
	resp      model.TestHelpersResponse
	url       *url.URL
	userAgent string
}

func (h *handleTestHelpers) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	var out model.TestHelpersResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForTestHelpers(t *testing.T) {
	// setup
	handler := &handleTestHelpers{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.TestHelpersRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.TestHelpers(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "GET" {
		t.Fatal("we sent an unexpected method")
	}
}

func TestPsiphonConfigInvalidURL(t *testing.T) {
	api := &psiphonConfigAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWithMissingAuthorizer(t *testing.T) {
	api := &psiphonConfigAPI{
		BaseURL: "https://ps1.ooni.io",
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMissingAuthorizer) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWithNewRequestErr(t *testing.T) {
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestPsiphonConfigResponseLiteralNull(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &psiphonConfigAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrJSONLiteralNull) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestPsiphonConfigWithFailingAuthorizer(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &psiphonConfigAPI{
		Authorizer: &failingAuthorizer{},
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

type handlePsiphonConfig struct {
	accept        string
	authorization string
	count         int32
	method        string
	mu            sync.Mutex
	resp          model.PsiphonConfigResponse
	url           *url.URL
	userAgent     string
}

func (h *handlePsiphonConfig) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.authorization = r.Header.Get("Authorization")
	h.userAgent = r.Header.Get("User-Agent")
	var out model.PsiphonConfigResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForPsiphonConfig(t *testing.T) {
	// setup
	handler := &handlePsiphonConfig{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.PsiphonConfigRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	kvstore := &memkvstore{}
	// hand-craft a state that does not require relogin
	lm := &loginManager{kvstore: kvstore, state: loginState{
		ClientID: "077c3985-b228-4df3-af22-bc3377c7a376",
		Expire:   time.Now().Add(3600 * time.Second),
		Password: "077c3985-b228-4df3-af22-bc3377c7a376",
		Token:    "077c3985-b228-4df3-af22-bc3377c7a376",
	}}
	lm.writeback() // memory never fails
	clnt.KVStore = kvstore
	// issue request
	ctx := context.Background()
	resp, err := clnt.PsiphonConfig(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	expectAuth := newAuthorizationHeader(lm.state.Token)
	if handler.authorization != expectAuth {
		t.Fatal("we sent an unexpected authorization header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "GET" {
		t.Fatal("we sent an unexpected method")
	}
}

func TestTorTargetsInvalidURL(t *testing.T) {
	api := &torTargetsAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWithMissingAuthorizer(t *testing.T) {
	api := &torTargetsAPI{
		BaseURL: "https://ps1.ooni.io",
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMissingAuthorizer) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWithNewRequestErr(t *testing.T) {
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestTorTargetsResponseLiteralNull(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &torTargetsAPI{
		Authorizer: newStaticAuthorizer("fakeToken"),
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrJSONLiteralNull) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestTorTargetsWithFailingAuthorizer(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &torTargetsAPI{
		Authorizer: &failingAuthorizer{},
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

type handleTorTargets struct {
	accept        string
	authorization string
	count         int32
	method        string
	mu            sync.Mutex
	resp          model.TorTargetsResponse
	url           *url.URL
	userAgent     string
}

func (h *handleTorTargets) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.authorization = r.Header.Get("Authorization")
	h.userAgent = r.Header.Get("User-Agent")
	var out model.TorTargetsResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForTorTargets(t *testing.T) {
	// setup
	handler := &handleTorTargets{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.TorTargetsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	kvstore := &memkvstore{}
	// hand-craft a state that does not require relogin
	lm := &loginManager{kvstore: kvstore, state: loginState{
		ClientID: "077c3985-b228-4df3-af22-bc3377c7a376",
		Expire:   time.Now().Add(3600 * time.Second),
		Password: "077c3985-b228-4df3-af22-bc3377c7a376",
		Token:    "077c3985-b228-4df3-af22-bc3377c7a376",
	}}
	lm.writeback() // memory never fails
	clnt.KVStore = kvstore
	// issue request
	ctx := context.Background()
	resp, err := clnt.TorTargets(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	expectAuth := newAuthorizationHeader(lm.state.Token)
	if handler.authorization != expectAuth {
		t.Fatal("we sent an unexpected authorization header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "GET" {
		t.Fatal("we sent an unexpected method")
	}
}

func TestURLsInvalidURL(t *testing.T) {
	api := &urlsAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestURLsWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &urlsAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestURLsWithNewRequestErr(t *testing.T) {
	api := &urlsAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestURLsWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &urlsAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestURLsWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &urlsAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestURLsWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &urlsAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestURLsRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &urlsAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

type handleURLs struct {
	accept    string
	count     int32
	method    string
	mu        sync.Mutex
	resp      *model.URLsResponse
	url       *url.URL
	userAgent string
}

func (h *handleURLs) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	var out model.URLsResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = &out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForURLs(t *testing.T) {
	// setup
	handler := &handleURLs{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.URLsRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.URLs(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if reflect.ValueOf(*resp).IsZero() {
		t.Fatal("server returned a zero structure")
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "GET" {
		t.Fatal("we sent an unexpected method")
	}
	// check for the query
	query, err := url.ParseQuery(handler.url.RawQuery)
	if err != nil {
		t.Fatal(err)
	}
	v0 := query.Get("category_codes")
	ov0 := req.CategoryCodes
	if ov0 != v0 {
		t.Fatal("query field with unexpected value")
	}
	v1 := query.Get("country_code")
	ov1 := req.CountryCode
	if ov1 != v1 {
		t.Fatal("query field with unexpected value")
	}
	v2 := query.Get("limit")
	if v2 == "" {
		v2 = "0" // we don't send a zero value
	}
	ov2 := newQueryFieldInt64(req.Limit)
	if ov2 != v2 {
		t.Fatal("query field with unexpected value")
	}
}

func TestOpenReportInvalidURL(t *testing.T) {
	api := &openReportAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &openReportAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportMarshalErr(t *testing.T) {
	api := &openReportAPI{
		BaseURL: "https://ps1.ooni.io",
		marshal: func(v interface{}) ([]byte, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportWithNewRequestErr(t *testing.T) {
	api := &openReportAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &openReportAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &openReportAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &openReportAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestOpenReportRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &openReportAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

type handleOpenReport struct {
	accept    string
	req       *model.OpenReportRequest
	count     int32
	method    string
	mu        sync.Mutex
	resp      *model.OpenReportResponse
	url       *url.URL
	userAgent string
}

func (h *handleOpenReport) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	reqbody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	var in model.OpenReportRequest
	if err := json.Unmarshal(reqbody, &in); err != nil {
		w.WriteHeader(400)
		return
	}
	if reflect.ValueOf(in).IsZero() {
		w.WriteHeader(400)
		return
	}
	h.req = &in
	var out model.OpenReportResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = &out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForOpenReport(t *testing.T) {
	// setup
	handler := &handleOpenReport{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.OpenReportRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.OpenReport(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if reflect.ValueOf(*resp).IsZero() {
		t.Fatal("server returned a zero structure")
	}
	if diff := cmp.Diff(req, handler.req); diff != "" {
		t.Fatal(diff)
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "POST" {
		t.Fatal("we sent an unexpected method")
	}
}

func TestSubmitMeasurementInvalidURL(t *testing.T) {
	api := &submitMeasurementAPI{
		BaseURL: "\t", // invalid
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err == nil || !strings.HasSuffix(err.Error(), "invalid control character in URL") {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementWithHTTPErr(t *testing.T) {
	clnt := &mockableHTTPClient{Err: errMocked}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementMarshalErr(t *testing.T) {
	api := &submitMeasurementAPI{
		BaseURL: "https://ps1.ooni.io",
		marshal: func(v interface{}) ([]byte, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementWithNewRequestErr(t *testing.T) {
	api := &submitMeasurementAPI{
		BaseURL: "https://ps1.ooni.io",
		NewRequest: func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error) {
			return nil, errMocked
		},
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementWith400(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{StatusCode: 400}}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, ErrHTTPFailure) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementWithResponseBodyReadErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableBodyWithFailure{},
	}}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementWithUnmarshalFailure(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		unmarshal: func(b []byte, v interface{}) error {
			return errMocked
		},
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementRoundTrip(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableEmptyBody{},
	}}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
}

func TestSubmitMeasurementTemplateParseErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		newTemplate: func(name string) textTemplate {
			return &templateParseError{}
		},
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

func TestSubmitMeasurementTemplateExecuteErr(t *testing.T) {
	clnt := &mockableHTTPClient{Resp: &http.Response{
		StatusCode: 200,
		Body:       &mockableLiteralNull{},
	}}
	api := &submitMeasurementAPI{
		BaseURL:    "https://ps1.ooni.io",
		HTTPClient: clnt,
		newTemplate: func(name string) textTemplate {
			return &templateExecuteError{}
		},
	}
	ctx := context.Background()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	resp, err := api.call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil resp")
	}
}

type handleSubmitMeasurement struct {
	accept    string
	req       *model.SubmitMeasurementRequest
	count     int32
	method    string
	mu        sync.Mutex
	resp      *model.SubmitMeasurementResponse
	url       *url.URL
	userAgent string
}

func (h *handleSubmitMeasurement) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer h.mu.Unlock()
	h.mu.Lock()
	if h.count > 0 {
		w.WriteHeader(400)
		return
	}
	h.count++
	h.method = r.Method
	h.url = r.URL
	h.accept = r.Header.Get("Accept")
	h.userAgent = r.Header.Get("User-Agent")
	reqbody, err := ioutil.ReadAll(r.Body)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	var in model.SubmitMeasurementRequest
	if err := json.Unmarshal(reqbody, &in); err != nil {
		w.WriteHeader(400)
		return
	}
	if reflect.ValueOf(in).IsZero() {
		w.WriteHeader(400)
		return
	}
	h.req = &in
	var out model.SubmitMeasurementResponse
	ff := fakeFill{}
	ff.fill(&out)
	h.resp = &out
	data, err := json.Marshal(out)
	if err != nil {
		w.WriteHeader(400)
		return
	}
	w.Write(data)
}

func TestClientWithHandlerForSubmitMeasurement(t *testing.T) {
	// setup
	handler := &handleSubmitMeasurement{}
	srvr := httptest.NewServer(handler)
	defer srvr.Close()
	req := &model.SubmitMeasurementRequest{}
	ff := &fakeFill{}
	ff.fill(req)
	clnt := &Client{
		BaseURL: srvr.URL,
	}
	ff.fill(&clnt.UserAgent)
	// issue request
	ctx := context.Background()
	resp, err := clnt.SubmitMeasurement(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	// check for data round trip
	if resp == nil {
		t.Fatal("expected non-nil resp")
	}
	if reflect.ValueOf(*resp).IsZero() {
		t.Fatal("server returned a zero structure")
	}
	if diff := cmp.Diff(req, handler.req); diff != "" {
		t.Fatal(diff)
	}
	if diff := cmp.Diff(resp, handler.resp); diff != "" {
		t.Fatal(diff)
	}
	if handler.accept != "application/json" {
		t.Fatal("we sent an unexpected accept header")
	}
	if handler.userAgent != clnt.UserAgent {
		t.Fatal("we sent an unexpected User-Agent header")
	}
	if handler.method != "POST" {
		t.Fatal("we sent an unexpected method")
	}
}
