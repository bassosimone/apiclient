// Code generated by go generate; DO NOT EDIT.
// 2021-02-17 15:15:08.203901633 +0100 CET m=+0.000196472

package apiclient

import (
	"bytes"
	"context"
	"encoding/json"
	"io/ioutil"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/bassosimone/apiclient/internal/imodel"
	"github.com/bassosimone/apiclient/model"
)

//go:generate go run ./internal/cmd/generator

// CheckReportID calls the CheckReportID API.
func (c *Client) CheckReportID(ctx context.Context, req *model.CheckReportIDRequest) (*model.CheckReportIDResponse, error) {
	return newCheckReportIDAPI(c).call(ctx, req)
}

type checkReportIDAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newCheckReportIDAPI(c *Client) *checkReportIDAPI {
	api := &checkReportIDAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *checkReportIDAPI) call(ctx context.Context, in *model.CheckReportIDRequest) (*model.CheckReportIDResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *checkReportIDAPI) newRequestQuery(req *model.CheckReportIDRequest) (string, error) {
	q := url.Values{}
	if req.ReportID == "" {
		return "", newErrEmptyField("ReportID")
	}
	q.Add("report_id", req.ReportID)
	return q.Encode(), nil
}

func (api *checkReportIDAPI) newRequest(ctx context.Context, req *model.CheckReportIDRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/_/check_report_id"
	URL.RawQuery, err = api.newRequestQuery(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *checkReportIDAPI) newResponse(resp *http.Response, err error) (*model.CheckReportIDResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.CheckReportIDResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// CheckIn calls the CheckIn API.
func (c *Client) CheckIn(ctx context.Context, req *model.CheckInRequest) (*model.CheckInResponse, error) {
	return newCheckInAPI(c).call(ctx, req)
}

type checkInAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newCheckInAPI(c *Client) *checkInAPI {
	api := &checkInAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *checkInAPI) call(ctx context.Context, in *model.CheckInRequest) (*model.CheckInResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *checkInAPI) newRequest(ctx context.Context, req *model.CheckInRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/check-in"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *checkInAPI) newResponse(resp *http.Response, err error) (*model.CheckInResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.CheckInResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

type loginAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newLoginAPI(c *Client) *loginAPI {
	api := &loginAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *loginAPI) call(ctx context.Context, in *imodel.LoginRequest) (*imodel.LoginResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *loginAPI) newRequest(ctx context.Context, req *imodel.LoginRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/login"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *loginAPI) newResponse(resp *http.Response, err error) (*imodel.LoginResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &imodel.LoginResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// MeasurementMeta calls the MeasurementMeta API.
func (c *Client) MeasurementMeta(ctx context.Context, req *model.MeasurementMetaRequest) (*model.MeasurementMetaResponse, error) {
	return newMeasurementMetaAPI(c).call(ctx, req)
}

type measurementMetaAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newMeasurementMetaAPI(c *Client) *measurementMetaAPI {
	api := &measurementMetaAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *measurementMetaAPI) call(ctx context.Context, in *model.MeasurementMetaRequest) (*model.MeasurementMetaResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *measurementMetaAPI) newRequestQuery(req *model.MeasurementMetaRequest) (string, error) {
	q := url.Values{}
	if req.ReportID == "" {
		return "", newErrEmptyField("ReportID")
	}
	q.Add("report_id", req.ReportID)
	if req.Full {
		q.Add("full", "true")
	}
	if req.Input != "" {
		q.Add("input", req.Input)
	}
	return q.Encode(), nil
}

func (api *measurementMetaAPI) newRequest(ctx context.Context, req *model.MeasurementMetaRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/measurement_meta"
	URL.RawQuery, err = api.newRequestQuery(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *measurementMetaAPI) newResponse(resp *http.Response, err error) (*model.MeasurementMetaResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.MeasurementMetaResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

type registerAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newRegisterAPI(c *Client) *registerAPI {
	api := &registerAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *registerAPI) call(ctx context.Context, in *imodel.RegisterRequest) (*imodel.RegisterResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *registerAPI) newRequest(ctx context.Context, req *imodel.RegisterRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/register"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *registerAPI) newResponse(resp *http.Response, err error) (*imodel.RegisterResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &imodel.RegisterResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// TestHelpers calls the TestHelpers API.
func (c *Client) TestHelpers(ctx context.Context, req *model.TestHelpersRequest) (model.TestHelpersResponse, error) {
	return newTestHelpersAPI(c).call(ctx, req)
}

type testHelpersAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newTestHelpersAPI(c *Client) *testHelpersAPI {
	api := &testHelpersAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *testHelpersAPI) call(ctx context.Context, in *model.TestHelpersRequest) (model.TestHelpersResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *testHelpersAPI) newRequest(ctx context.Context, req *model.TestHelpersRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-helpers"
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *testHelpersAPI) newResponse(resp *http.Response, err error) (model.TestHelpersResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := model.TestHelpersResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

// PsiphonConfig calls the PsiphonConfig API.
func (c *Client) PsiphonConfig(ctx context.Context, req *model.PsiphonConfigRequest) (model.PsiphonConfigResponse, error) {
	return newPsiphonConfigAPI(c).call(ctx, req)
}

type psiphonConfigAPI struct {
	Authorizer authorizer
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newPsiphonConfigAPI(c *Client) *psiphonConfigAPI {
	api := &psiphonConfigAPI{
		Authorizer: c,
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *psiphonConfigAPI) call(ctx context.Context, in *model.PsiphonConfigRequest) (model.PsiphonConfigResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	if api.Authorizer == nil {
		return nil, errMissingAuthorizer
	}
	token, err := api.Authorizer.maybeRefreshToken(ctx)
	if err != nil {
		return nil, err
	}
	authorization := newAuthorizationHeader(token)
	req.Header.Add("Authorization", authorization)
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *psiphonConfigAPI) newRequest(ctx context.Context, req *model.PsiphonConfigRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-list/psiphon-config"
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *psiphonConfigAPI) newResponse(resp *http.Response, err error) (model.PsiphonConfigResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := model.PsiphonConfigResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

// TorTargets calls the TorTargets API.
func (c *Client) TorTargets(ctx context.Context, req *model.TorTargetsRequest) (model.TorTargetsResponse, error) {
	return newTorTargetsAPI(c).call(ctx, req)
}

type torTargetsAPI struct {
	Authorizer authorizer
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newTorTargetsAPI(c *Client) *torTargetsAPI {
	api := &torTargetsAPI{
		Authorizer: c,
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *torTargetsAPI) call(ctx context.Context, in *model.TorTargetsRequest) (model.TorTargetsResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	if api.Authorizer == nil {
		return nil, errMissingAuthorizer
	}
	token, err := api.Authorizer.maybeRefreshToken(ctx)
	if err != nil {
		return nil, err
	}
	authorization := newAuthorizationHeader(token)
	req.Header.Add("Authorization", authorization)
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *torTargetsAPI) newRequest(ctx context.Context, req *model.TorTargetsRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-list/tor-targets"
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *torTargetsAPI) newResponse(resp *http.Response, err error) (model.TorTargetsResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := model.TorTargetsResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, &out); err != nil {
		return nil, err
	}
	if out == nil {
		return nil, ErrJSONLiteralNull
	}
	return out, nil
}

// URLs calls the URLs API.
func (c *Client) URLs(ctx context.Context, req *model.URLsRequest) (*model.URLsResponse, error) {
	return newURLsAPI(c).call(ctx, req)
}

type urlsAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newURLsAPI(c *Client) *urlsAPI {
	api := &urlsAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *urlsAPI) call(ctx context.Context, in *model.URLsRequest) (*model.URLsResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *urlsAPI) newRequestQuery(req *model.URLsRequest) (string, error) {
	q := url.Values{}
	if req.CategoryCodes != "" {
		q.Add("category_codes", req.CategoryCodes)
	}
	if req.CountryCode != "" {
		q.Add("country_code", req.CountryCode)
	}
	if req.Limit != 0 {
		q.Add("limit", newQueryFieldInt64(req.Limit))
	}
	return q.Encode(), nil
}

func (api *urlsAPI) newRequest(ctx context.Context, req *model.URLsRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/api/v1/test-list/urls"
	URL.RawQuery, err = api.newRequestQuery(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	return newRequest(ctx, "GET", URL.String(), nil)
}

func (api *urlsAPI) newResponse(resp *http.Response, err error) (*model.URLsResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.URLsResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// OpenReport calls the OpenReport API.
func (c *Client) OpenReport(ctx context.Context, req *model.OpenReportRequest) (*model.OpenReportResponse, error) {
	return newOpenReportAPI(c).call(ctx, req)
}

type openReportAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	unmarshal   func(b []byte, v interface{}) error
}

func newOpenReportAPI(c *Client) *openReportAPI {
	api := &openReportAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *openReportAPI) call(ctx context.Context, in *model.OpenReportRequest) (*model.OpenReportResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *openReportAPI) newRequest(ctx context.Context, req *model.OpenReportRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path = "/report"
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *openReportAPI) newResponse(resp *http.Response, err error) (*model.OpenReportResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.OpenReportResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

// SubmitMeasurement calls the SubmitMeasurement API.
func (c *Client) SubmitMeasurement(ctx context.Context, req *model.SubmitMeasurementRequest) (*model.SubmitMeasurementResponse, error) {
	return newSubmitMeasurementAPI(c).call(ctx, req)
}

type submitMeasurementAPI struct {
	BaseURL     string
	HTTPClient  HTTPClient
	NewRequest  func(ctx context.Context, method, URL string, body io.Reader) (*http.Request, error)
	UserAgent   string
	marshal     func(v interface{}) ([]byte, error)
	newTemplate func(s string) textTemplate
	unmarshal   func(b []byte, v interface{}) error
}

func newSubmitMeasurementAPI(c *Client) *submitMeasurementAPI {
	api := &submitMeasurementAPI{
		BaseURL: c.baseURL(),
		HTTPClient: c.HTTPClient,
		UserAgent: c.UserAgent,
	}
	return api
}

func (api *submitMeasurementAPI) call(ctx context.Context, in *model.SubmitMeasurementRequest) (*model.SubmitMeasurementResponse, error) {
	req, err := api.newRequest(ctx, in)
	if err != nil {
		return nil, err
	}
	req.Header.Add("Accept", "application/json")
	req.Header.Add("User-Agent", api.UserAgent)
	var httpClient HTTPClient = http.DefaultClient
	if api.HTTPClient != nil {
		httpClient = api.HTTPClient
	}
	return api.newResponse(httpClient.Do(req))
}

func (api *submitMeasurementAPI) newRequestURLPath(req *model.SubmitMeasurementRequest) (string, error) {
	newTemplate := newStdlibTextTemplate
	if api.newTemplate != nil {
		newTemplate = api.newTemplate
	}
	tmpl, err := newTemplate("urlpath").Parse("/report/{{ .ReportID }}")
	if err != nil {
		return "", err
	}
	var urlpath strings.Builder
	err = tmpl.Execute(&urlpath, req)
	if err != nil {
		return "", err
	}
	return urlpath.String(), nil
}

func (api *submitMeasurementAPI) newRequest(ctx context.Context, req *model.SubmitMeasurementRequest) (*http.Request, error) {
	URL, err := url.Parse(api.BaseURL)
	if err != nil {
		return nil, err
	}
	URL.Path, err = api.newRequestURLPath(req)
	if err != nil {
		return nil, err
	}
	marshal := json.Marshal
	if api.marshal != nil {
		marshal = api.marshal
	}
	body, err := marshal(req)
	if err != nil {
		return nil, err
	}
	newRequest := http.NewRequestWithContext
	if api.NewRequest != nil {
		newRequest = api.NewRequest
	}
	out, err := newRequest(ctx, "POST", URL.String(), bytes.NewReader(body))
	if err != nil {
		return nil, err
	}
	out.Header.Set("Content-Type", "application/json")
	return out, nil
}

func (api *submitMeasurementAPI) newResponse(resp *http.Response, err error) (*model.SubmitMeasurementResponse, error) {
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != 200 {
		return nil, newHTTPFailure(resp.StatusCode)
	}
	defer resp.Body.Close()
	reader := io.LimitReader(resp.Body, 4<<20)
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	out := &model.SubmitMeasurementResponse{}
	unmarshal := json.Unmarshal
	if api.unmarshal != nil {
		unmarshal = api.unmarshal
	}
	if err := unmarshal(data, out); err != nil {
		return nil, err
	}
	return out, nil
}

var swagger = `{
    "swagger": "2.0",
    "info": {
        "title": "OONI API specification",
        "version": "0.20210217.2141508"
    },
    "host": "api.ooni.io",
    "basePath": "/",
    "schemes": [
        "https"
    ],
    "paths": {
        "/api/_/check_report_id": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "query",
                        "name": "report_id",
                        "required": true,
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "found": {
                                    "type": "boolean"
                                },
                                "v": {
                                    "type": "integer"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/check-in": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                            "properties": {
                                "charging": {
                                    "type": "boolean"
                                },
                                "on_wifi": {
                                    "type": "boolean"
                                },
                                "platform": {
                                    "type": "string"
                                },
                                "probe_asn": {
                                    "type": "string"
                                },
                                "probe_cc": {
                                    "type": "string"
                                },
                                "run_type": {
                                    "type": "string"
                                },
                                "software_name": {
                                    "type": "string"
                                },
                                "software_version": {
                                    "type": "string"
                                },
                                "web_connectivity": {
                                    "properties": {
                                        "category_codes": {
                                            "items": {
                                                "type": "string"
                                            },
                                            "type": "array"
                                        }
                                    },
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "web_connectivity": {
                                    "properties": {
                                        "report_id": {
                                            "type": "string"
                                        },
                                        "urls": {
                                            "items": {
                                                "properties": {
                                                    "category_code": {
                                                        "type": "string"
                                                    },
                                                    "country_code": {
                                                        "type": "string"
                                                    },
                                                    "url": {
                                                        "type": "string"
                                                    }
                                                },
                                                "type": "object"
                                            },
                                            "type": "array"
                                        }
                                    },
                                    "type": "object"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/login": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                            "properties": {
                                "password": {
                                    "type": "string"
                                },
                                "username": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "expire": {
                                    "type": "string"
                                },
                                "token": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/measurement_meta": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "query",
                        "name": "report_id",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "in": "query",
                        "name": "full",
                        "type": "boolean"
                    },
                    {
                        "in": "query",
                        "name": "input",
                        "type": "string"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "anomaly": {
                                    "type": "boolean"
                                },
                                "category_code": {
                                    "type": "string"
                                },
                                "confirmed": {
                                    "type": "boolean"
                                },
                                "failure": {
                                    "type": "boolean"
                                },
                                "input": {
                                    "type": "string"
                                },
                                "measurement_start_time": {
                                    "type": "string"
                                },
                                "probe_asn": {
                                    "type": "integer"
                                },
                                "probe_cc": {
                                    "type": "string"
                                },
                                "raw_measurement": {
                                    "type": "string"
                                },
                                "report_id": {
                                    "type": "string"
                                },
                                "scores": {
                                    "type": "string"
                                },
                                "test_name": {
                                    "type": "string"
                                },
                                "test_start_time": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/register": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                            "properties": {
                                "metadata": {
                                    "properties": {
                                        "available_bandwidth": {
                                            "type": "string"
                                        },
                                        "device_token": {
                                            "type": "string"
                                        },
                                        "language": {
                                            "type": "string"
                                        },
                                        "network_type": {
                                            "type": "string"
                                        },
                                        "platform": {
                                            "type": "string"
                                        },
                                        "probe_asn": {
                                            "type": "string"
                                        },
                                        "probe_cc": {
                                            "type": "string"
                                        },
                                        "probe_family": {
                                            "type": "string"
                                        },
                                        "probe_timezone": {
                                            "type": "string"
                                        },
                                        "software_name": {
                                            "type": "string"
                                        },
                                        "software_version": {
                                            "type": "string"
                                        },
                                        "supported_tests": {
                                            "items": {
                                                "type": "string"
                                            },
                                            "type": "array"
                                        }
                                    },
                                    "type": "object"
                                },
                                "password": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "client_id": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/test-helpers": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/test-list/psiphon-config": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/test-list/tor-targets": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/api/v1/test-list/urls": {
            "get": {
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "query",
                        "name": "category_codes",
                        "type": "string"
                    },
                    {
                        "in": "query",
                        "name": "country_code",
                        "type": "string"
                    },
                    {
                        "in": "query",
                        "name": "limit",
                        "type": "integer"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "metadata": {
                                    "properties": {
                                        "count": {
                                            "type": "integer"
                                        }
                                    },
                                    "type": "object"
                                },
                                "results": {
                                    "items": {
                                        "properties": {
                                            "category_code": {
                                                "type": "string"
                                            },
                                            "country_code": {
                                                "type": "string"
                                            },
                                            "url": {
                                                "type": "string"
                                            }
                                        },
                                        "type": "object"
                                    },
                                    "type": "array"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/report": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                            "properties": {
                                "data_format_version": {
                                    "type": "string"
                                },
                                "format": {
                                    "type": "string"
                                },
                                "probe_asn": {
                                    "type": "string"
                                },
                                "probe_cc": {
                                    "type": "string"
                                },
                                "software_name": {
                                    "type": "string"
                                },
                                "software_version": {
                                    "type": "string"
                                },
                                "test_name": {
                                    "type": "string"
                                },
                                "test_start_time": {
                                    "type": "string"
                                },
                                "test_version": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "report_id": {
                                    "type": "string"
                                },
                                "supported_formats": {
                                    "items": {
                                        "type": "string"
                                    },
                                    "type": "array"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        },
        "/report/{report_id}": {
            "post": {
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "parameters": [
                    {
                        "in": "path",
                        "name": "report_id",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "in": "body",
                        "name": "body",
                        "required": true,
                        "schema": {
                            "properties": {
                                "content": {
                                    "type": "object"
                                },
                                "format": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "all good",
                        "schema": {
                            "properties": {
                                "measurement_uid": {
                                    "type": "string"
                                }
                            },
                            "type": "object"
                        }
                    }
                }
            }
        }
    }
}`
